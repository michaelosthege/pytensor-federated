import asyncio
import logging
from typing import Callable, List, Sequence, Tuple

import numpy as np
from grpclib.client import Channel

from .npproto.utils import ndarray_from_numpy, ndarray_to_numpy
from .rpc import (
    FederatedLogpOpBase,
    FederatedLogpOpInput,
    FederatedLogpOpOutput,
    FederatedLogpOpStub,
)

_log = logging.getLogger(__file__)


LogpGradFunc = Callable[
    [Sequence[np.ndarray]],  # arbitrary number of input arrays
    Tuple[np.ndarray, List[np.ndarray]],  # scalar log-p and gradients w.r.t. each input
]


def _compute_federated_logp(
    flop_input: FederatedLogpOpInput,
    perform_grad: LogpGradFunc,
) -> FederatedLogpOpOutput:
    """Wraps a ``perform_grad`` function with gRPC message decoding/encoding.

    Parameters
    ----------
    flop_input
        FederatedLogp input gRPC message.
    perform_grad
        The blackbox logp-gradient function.

    Returns
    -------
    flop_output
        FederatedLogp output gRPC message.
    """
    # Deserialize input arrays
    inputs = [ndarray_to_numpy(i) for i in flop_input.inputs]
    # Run the computation
    logp, gradients = perform_grad(*inputs)
    assert logp.shape == ()
    assert len(gradients) == len(inputs), f"inputs: {inputs}, gradients: {gradients}"
    # Encode results
    result = FederatedLogpOpOutput(
        log_potential=ndarray_from_numpy(logp),
        gradients=[ndarray_from_numpy(g) for g in gradients],
    )
    return result


class FederatedLogpOpService(FederatedLogpOpBase):
    """Implements the FederatedLogp service."""

    def __init__(
        self,
        perform_grad: LogpGradFunc,
    ) -> None:
        self._perform_grad = perform_grad
        super().__init__()

    async def evaluate(
        self,
        federated_logp_op_input: FederatedLogpOpInput,
    ) -> FederatedLogpOpOutput:
        return _compute_federated_logp(federated_logp_op_input, self._perform_grad)


class FederatedLogpOpClient:
    """Client wrapper around the autogenerated gRPC client implementation."""

    def __init__(self, host: str, port: int) -> None:
        """Create a wrapper around the FederatedLogpOp gRPC client.

        Parameters
        ----------
        host : str
            IP address or host name of the remote gRPC server.
        port : int
            Port of the gRPC server.
        """
        self._channel = Channel(host, port)
        self._client = FederatedLogpOpStub(self._channel)
        super().__init__()

    def __del__(self):
        self._channel.close()
        return

    def evaluate(self, *inputs: Sequence[np.ndarray]) -> Tuple[np.ndarray, List[np.ndarray]]:
        """Evaluate the federated blackbox logp gradient function on inputs.

        Parameters
        ----------
        *inputs
            NumPy `ndarray` inputs.
        use_stream : bool
            If ``True`` (default), the RPC is performed through a bidirectional stream,
            which is much faster than sending individual (unary/unary) RPCs.

        Returns
        -------
        logp : ndarray
            The log-potential of the federated blackbox function.
        *gradients
            Sequence of ``ndarray`` with gradients of ``logp`` w.r.t. ``inputs``.
        """
        # Encode inputs
        fpi = FederatedLogpOpInput(inputs=[ndarray_from_numpy(i) for i in inputs])

        # Make the asynchronous calls to the remote server
        eval_task = self._client.evaluate(fpi)
        loop = asyncio.get_event_loop()

        # Decode outputs
        logp = ndarray_to_numpy(fpo.log_potential)
        gradient = [ndarray_to_numpy(g) for g in fpo.gradients]
        return logp, gradient
